<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>OnchainRug #1</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center
    }

    #defaultCanvas0 {
      width: 100% !important;
      height: auto !important;
    }

  </style>
</head>

<body>
  <script>
    const _p5 = {
      ctx: null,
      canvas: null,
      width: 0,
      height: 0,
      fillStyle: null,
      strokeStyle: "#000",
      doFill: !0,
      doStroke: !0,
      blend: "source-over",
      stack: [],
      pixelDensity: 1
    };

    function createCanvas(e, t) {
      const l = document.createElement("canvas");
      _p5.width = e, _p5.height = t, document.querySelector("#defaultCanvas0") || (l.id = "defaultCanvas0");
      const r = _p5.pixelDensity || 1;
      return l.width = Math.floor(e * r), l.height = Math.floor(t * r), l.style.width = e + "px", l.style.height = t + "px", _p5.canvas = l, _p5.ctx = l.getContext("2d"), _p5.ctx.setTransform(1, 0, 0, 1, 0, 0), _p5.ctx.scale(r, r), Object.defineProperty(window, "width", {
        get: () => _p5.width
      }), Object.defineProperty(window, "height", {
        get: () => _p5.height
      }), document.body.appendChild(l), {
        elt: l,
        parent: function(e) {
          const t = "string" == typeof e ? document.getElementById(e) : e;
          t && t.appendChild(l)
        }
      }
    }
    let _noLoop = !1;

    function noLoop() {
      _noLoop = !0, window.noLoopCalled = !0
    }

    function pixelDensity(e) {
      _p5.pixelDensity = e, _p5.canvas && (_p5.canvas.width = Math.floor(_p5.width * e), _p5.canvas.height = Math.floor(_p5.height * e), _p5.canvas.style.width = _p5.width + "px", _p5.canvas.style.height = _p5.height + "px", _p5.ctx.setTransform(1, 0, 0, 1, 0, 0), _p5.ctx.scale(e, e))
    }

    function background(e, t, l, r) {
      if (_p5.ctx) {
        if (_p5.ctx.save(), "string" == typeof e) {
          _p5.ctx.globalAlpha = 1, _p5.ctx.fillStyle = e, _p5.ctx.fillRect(0, 0, _p5.width, _p5.height), _p5.ctx.restore();
          return
        }
        void 0 === r && (r = 255), _p5.ctx.globalAlpha = r / 255, _p5.ctx.fillStyle = `rgb(${e},${t},${l})`, _p5.ctx.fillRect(0, 0, _p5.width, _p5.height), _p5.ctx.restore()
      }
    }

    function _hexToLevels(e) {
      if (3 === (e = String(e).replace("#", "").trim()).length && (e = e.split("").map(e => e + e).join("")), 6 !== e.length) return null;
      const t = parseInt(e.slice(0, 2), 16),
        l = parseInt(e.slice(2, 4), 16),
        r = parseInt(e.slice(4, 6), 16);
      return [t, l, r, 255]
    }

    function color(e, t, l, r) {
      if ("object" == typeof e && null !== e && "levels" in e) return e;
      if ("string" == typeof e) {
        const o = _hexToLevels(e);
        if (o) {
          const [n, p, i, c] = o;
          return {
            levels: [n, p, i, c],
            toString: () => c < 255 ? `rgba(${n},${p},${i},${c/255})` : `rgb(${n},${p},${i})`
          }
        }
        const a = e.match(/rgba?\(([^)]+)\)/);
        if (a) {
          const s = a[1].split(",").map(e => e.trim()),
            f = Number(s[0]) || 0,
            d = Number(s[1]) || 0,
            u = Number(s[2]) || 0,
            h = s[3] ? Math.round(255 * Number(s[3])) : 255;
          return {
            levels: [f, d, u, h],
            toString: () => h < 255 ? `rgba(${f},${d},${u},${h/255})` : `rgb(${f},${d},${u})`
          }
        }
        return {
          levels: [0, 0, 0, 255],
          toString: () => e
        }
      }
      return void 0 === t && (t = e, l = e), void 0 === r && (r = 255), {
        levels: [e, t, l, r],
        toString: () => r < 255 ? `rgba(${e},${t},${l},${r/255})` : `rgb(${e},${t},${l})`
      }
    }

    function fill(e, t, l, r) {
      if (_p5.doFill = !0, "object" == typeof e && e.levels) {
        _p5.fillStyle = e.toString();
        return
      }
      if ("string" == typeof e && void 0 === t) {
        _p5.fillStyle = color(e).toString();
        return
      }
      void 0 === r && (r = 255), _p5.fillStyle = r < 255 ? `rgba(${e},${t},${l},${r/255})` : `rgb(${e},${t},${l})`
    }

    function noFill() {
      _p5.doFill = !1
    }

    function stroke(e, t, l, r) {
      if (_p5.doStroke = !0, "object" == typeof e && e.levels) {
        _p5.strokeStyle = e.toString();
        return
      }
      if ("string" == typeof e && void 0 === t) {
        _p5.strokeStyle = color(e).toString();
        return
      }
      void 0 === r && (r = 255), _p5.strokeStyle = r < 255 ? `rgba(${e},${t},${l},${r/255})` : `rgb(${e},${t},${l})`
    }

    function noStroke() {
      _p5.doStroke = !1
    }

    function strokeWeight(e) {
      _p5.ctx && (_p5.ctx.lineWidth = e)
    }

    function blendMode(e) {
      _p5.blend = e, _p5.ctx && (_p5.ctx.globalCompositeOperation = e || "source-over")
    }

    function rect(e, t, l, r) {
      _p5.ctx && (_p5.ctx.save(), _p5.ctx.globalCompositeOperation = _p5.blend, _p5.doFill && _p5.fillStyle && (_p5.ctx.fillStyle = _p5.fillStyle, _p5.ctx.fillRect(e, t, l, r)), _p5.doStroke && _p5.strokeStyle && (_p5.ctx.strokeStyle = _p5.strokeStyle, _p5.ctx.strokeRect(e, t, l, r)), _p5.ctx.restore())
    }

    function ellipse(e, t, l, r) {
      _p5.ctx && (_p5.ctx.save(), _p5.ctx.globalCompositeOperation = _p5.blend, _p5.ctx.beginPath(), _p5.ctx.ellipse(e, t, l / 2, r / 2, 0, 0, 2 * Math.PI), _p5.doFill && _p5.fillStyle && (_p5.ctx.fillStyle = _p5.fillStyle, _p5.ctx.fill()), _p5.doStroke && _p5.strokeStyle && (_p5.ctx.strokeStyle = _p5.strokeStyle, _p5.ctx.stroke()), _p5.ctx.restore())
    }

    function arc(e, t, l, r, o, n) {
      _p5.ctx && (_p5.ctx.save(), _p5.ctx.globalCompositeOperation = _p5.blend, _p5.ctx.beginPath(), _p5.ctx.ellipse(e, t, l / 2, r / 2, 0, o, n), _p5.doFill && _p5.fillStyle && (_p5.ctx.fillStyle = _p5.fillStyle, _p5.ctx.fill()), _p5.doStroke && _p5.strokeStyle && (_p5.ctx.strokeStyle = _p5.strokeStyle, _p5.ctx.stroke()), _p5.ctx.restore())
    }
    let _shp = null;

    function beginShape() {
      _shp = []
    }

    function vertex(e, t) {
      _shp && _shp.push([e, t])
    }

    function endShape(e = !1) {
      if (!_p5.ctx || !_shp || _shp.length < 2) {
        _shp = null;
        return
      }
      _p5.ctx.save(), _p5.ctx.globalCompositeOperation = _p5.blend, _p5.ctx.beginPath(), _p5.ctx.moveTo(_shp[0][0], _shp[0][1]);
      for (let t = 1; t < _shp.length; ++t) _p5.ctx.lineTo(_shp[t][0], _shp[t][1]);
      e && _p5.ctx.closePath(), _p5.doFill && _p5.fillStyle && (_p5.ctx.fillStyle = _p5.fillStyle, _p5.ctx.fill()), _p5.doStroke && _p5.strokeStyle && (_p5.ctx.strokeStyle = _p5.strokeStyle, _p5.ctx.stroke()), _p5.ctx.restore(), _shp = null
    }

    function push() {
      _p5.ctx && (_p5.ctx.save(), _p5.stack.push({
        fillStyle: _p5.fillStyle,
        strokeStyle: _p5.strokeStyle,
        doFill: _p5.doFill,
        doStroke: _p5.doStroke,
        blend: _p5.blend,
        lineWidth: _p5.ctx.lineWidth
      }))
    }

    function pop() {
      if (!_p5.ctx) return;
      _p5.ctx.restore();
      const e = _p5.stack.pop();
      e && (_p5.fillStyle = e.fillStyle, _p5.strokeStyle = e.strokeStyle, _p5.doFill = e.doFill, _p5.doStroke = e.doStroke, _p5.blend = e.blend, _p5.ctx && (_p5.ctx.globalCompositeOperation = _p5.blend), _p5.ctx && e.lineWidth && (_p5.ctx.lineWidth = e.lineWidth))
    }

    function translate(e, t) {
      _p5.ctx && _p5.ctx.translate(e, t)
    }

    function rotate(e) {
      _p5.ctx && _p5.ctx.rotate(e)
    }

    function red(e) {
      return e && e.levels ? e.levels[0] : 0
    }

    function green(e) {
      return e && e.levels ? e.levels[1] : 0
    }

    function blue(e) {
      return e && e.levels ? e.levels[2] : 0
    }

    function lerp(e, t, l) {
      return e + (t - e) * l
    }

    function lerpColor(e, t, l) {
      const r = e && e.levels ? e.levels : [0, 0, 0, 255],
        o = t && t.levels ? t.levels : [0, 0, 0, 255];
      return color(lerp(r[0], o[0], l), lerp(r[1], o[1], l), lerp(r[2], o[2], l), Math.round(lerp(r[3], o[3], l)))
    }

    function map(e, t, l, r, o) {
      return (e - t) / (l - t) * (o - r) + r
    }

    function constrain(e, t, l) {
      return Math.max(t, Math.min(l, e))
    }
    const PI = Math.PI,
      HALF_PI = Math.PI / 2;

    function sin(e) {
      return Math.sin(e)
    }

    function cos(e) {
      return Math.cos(e)
    }

    function max(...e) {
      return Math.max(...e)
    }

    function floor(e) {
      return Math.floor(e)
    }
    let _n = null,
      _ns = 4095,
      _no = 4,
      _nf = .5;

    function noiseSeed(e) {
      _n = [];
      let t = e >>> 0,
        l = () => (t = (1664525 * t + 1013904223) % 4294967296) / 4294967296;
      for (let r = 0; r < _ns + 1; r++) _n[r] = l()
    }

    function noise(e, t = 0, l = 0) {
      if (null === _n) {
        _n = [];
        for (let r = 0; r < _ns + 1; r++) _n[r] = Math.random()
      }
      e < 0 && (e = -e), t < 0 && (t = -t), l < 0 && (l = -l);
      let o = Math.floor(e),
        n = Math.floor(t),
        p = Math.floor(l),
        i = e - o,
        c = t - n,
        a = l - p,
        s = 0,
        f = .5,
        d, u, h;
      for (let x = 0; x < _no; x++) {
        const S = (o & _ns) + (n & _ns) * 157 + (p & _ns) * 113,
          $ = fade(i),
          y = fade(c);
        d = lerp(lerp(_n[S & _ns], _n[S + 1 & _ns], $), lerp(_n[S + 157 & _ns], _n[S + 158 & _ns], $), y), u = lerp(lerp(_n[S + 113 & _ns], _n[S + 114 & _ns], $), lerp(_n[S + 113 + 157 & _ns], _n[S + 113 + 158 & _ns], $), y), s += (h = lerp(d, u, fade(a))) * f, f *= _nf, o <<= 1, n <<= 1, c *= 2, p <<= 1, a *= 2, (i *= 2) >= 1 && (o++, i--), c >= 1 && (n++, c--), a >= 1 && (p++, a--)
      }
      return s
    }

    function fade(e) {
      return e * e * e * (e * (6 * e - 15) + 10)
    }
    let _r = Math.random;

    function randomSeed(e) {
      let t = e >>> 0;
      _r = function() {
        return (t = (1664525 * t + 1013904223) % 4294967296) / 4294967296
      }
    }

    function random(e, t) {
      return Array.isArray(e) ? e[Math.floor(_r() * e.length)] : void 0 === t ? void 0 === e ? _r() : _r() * e : e + _r() * (t - e)
    }
    window.createCanvas = createCanvas, window.noLoop = noLoop, window.pixelDensity = pixelDensity, window.background = background, window.fill = fill, window.noFill = noFill, window.stroke = stroke, window.noStroke = noStroke, window.strokeWeight = strokeWeight, window.blendMode = blendMode, window.rect = rect, window.ellipse = ellipse, window.arc = arc, window.beginShape = beginShape, window.vertex = vertex, window.endShape = endShape, window.push = push, window.pop = pop, window.translate = translate, window.rotate = rotate, window.color = color, window.lerp = lerp, window.lerpColor = lerpColor, window.map = map, window.constrain = constrain, window.noise = noise, window.noiseSeed = noiseSeed, window.PI = PI, window.HALF_PI = HALF_PI, window.sin = sin, window.cos = cos, window.max = max, window.floor = floor, window.red = red, window.green = green, window.blue = blue, window.random = random, window.randomSeed = randomSeed, window.MULTIPLY = "multiply", window.SCREEN = "screen", window.OVERLAY = "overlay", window.DARKEST = "darken", window.LIGHTEST = "lighten", window.addEventListener("load", () => {
      if ("function" == typeof window.setup) try {
        window.setup()
      } catch (e) {
        console.error("setup() error", e)
      }
      if ("function" == typeof window.draw) {
        if (_noLoop) try {
          window.draw()
        } catch (t) {
          console.error("draw() error", t)
        } else {
          const l = () => {
            try {
              window.draw()
            } catch (e) {
              console.error("draw() error", e)
            }
            requestAnimationFrame(l)
          };
          l()
        }
      }
    });

  </script>
  <div id="rug"></div>
  <script>
    let w = 800,
      h = 1200,
      f = 30,
      wt = 8,
      wp = 1,
      ts = 2,
      lt, dt, p = '{"name":"Cornell Red","colors":["#b31b1b","#ffffff","#222222","#e5e5e5"]}',
      sd = '[{"y":0,"h":42.02914133667946,"pc":"#ffffff","wt":"s","wv":0.4422280300408602},{"y":42.02914133667946,"h":20.858790008351207,"pc":"#b31b1b","wt":"s","wv":0.37214073780924084},{"y":62.887931345030665,"h":71.14094094838947,"pc":"#b31b1b","wt":"s","wv":0.17762625366449358},{"y":134.02887229342014,"h":38.8819016655907,"pc":"#ffffff","wt":"s","wv":0.35163085665553806},{"y":172.91077395901084,"h":74.22637629322708,"pc":"#222222","wt":"t","wv":0.22216905169188977},{"y":247.13715025223792,"h":76.19787557749078,"pc":"#e5e5e5","wt":"s","wv":0.2525822060182691},{"y":323.3350258297287,"h":57.36597998999059,"pc":"#e5e5e5","wt":"s","wv":0.29212067201733594},{"y":380.7010058197193,"h":37.52165462356061,"pc":"#b31b1b","wt":"s","wv":0.139495880715549},{"y":418.2226604432799,"h":74.40614832565188,"pc":"#e5e5e5","wt":"s","wv":0.4840020153671504},{"y":492.6288087689318,"h":77.33831094345078,"pc":"#ffffff","wt":"s","wv":0.15013499949127437},{"y":569.9671197123826,"h":72.08860404323786,"pc":"#222222","wt":"s","wv":0.11733965873718262},{"y":642.0557237556204,"h":70.6544792582281,"pc":"#b31b1b","wt":"t","wv":0.3415940409526229},{"y":712.7102030138485,"h":48.132348638027906,"pc":"#222222","sc":"#ffffff","wt":"m","wv":0.3241278420202434},{"y":760.8425516518764,"h":30.476979562081397,"pc":"#e5e5e5","sc":"#ffffff","wt":"s","wv":0.4536495808511972},{"y":791.3195312139578,"h":67.31258263578638,"pc":"#ffffff","wt":"t","wv":0.1285396555438638},{"y":858.6321138497442,"h":61.40321176033467,"pc":"#ffffff","wt":"t","wv":0.16178995668888094},{"y":920.0353256100789,"h":43.30076602753252,"pc":"#ffffff","wt":"s","wv":0.4802571332082153},{"y":963.3360916376114,"h":62.468554796651006,"pc":"#b31b1b","wt":"s","wv":0.29904599152505396},{"y":1025.8046464342624,"h":74.45465885801241,"pc":"#e5e5e5","wt":"s","wv":0.12250055391341448},{"y":1100.2593052922748,"h":33.09061186388135,"pc":"#e5e5e5","wt":"t","wv":0.3052842281758785},{"y":1133.3499171561562,"h":36.152822421863675,"pc":"#b31b1b","wt":"s","wv":0.13307057302445174},{"y":1169.5027395780198,"h":30.497260421980172,"pc":"#222222","wt":"s","wv":0.10931926853954793}]',
      tr = ["CURATOR"],
      td = [],
      s = 220823,
      cm = '{"C":["01111","10000","10000","10000","10000","10000","01111"],"U":["10001","10001","10001","10001","10001","10001","01110"],"R":["11110","10001","10001","11110","10100","10010","10001"],"A":["01110","10001","10001","11111","10001","10001","10001"],"T":["11111","00100","00100","00100","00100","00100","00100"],"O":["01110","10001","10001","10001","10001","10001","01110"]," ":["00000","00000","00000","00000","00000","00000","00000"]}',
      tl = 10,
      dl = 2,
      fl = "";
    p = JSON.parse(p);
    sd = JSON.parse(sd);
    cm = JSON.parse(cm);

  </script>
  <script>
    function setup() {
      noiseSeed(s), window.d = function($) {
        window.prngSeed = $ % 2147483647, window.prngSeed <= 0 && (window.prngSeed += 2147483646)
      }, window.b = function() {
        return window.prngSeed = 16807 * window.prngSeed % 2147483647, (window.prngSeed - 1) / 2147483646
      }, window.a = function($, t) {
        return $ + window.b() * (t - $)
      }, window.c = function($) {
        return $[Math.floor(window.b() * $.length)]
      }, window.d(s);
      const R = h + 4 * f,
        F = w + 4 * f;
      createCanvas(R + 2 * 55, F + 2 * 55).parent("rug");
      window.rW = R, window.rH = F, pixelDensity(2.5), u(), gtd(), noLoop()
    }

    function u() {
      if (!p || !p.colors) return;
      let $ = p.colors[0],
        t = p.colors[0],
        e = 999,
        l = -1;
      for (const o of p.colors) {
        const r = color(o),
          _ = (red(r) + green(r) + blue(r)) / 3;
        _ < e && (e = _, $ = o), _ > l && (l = _, t = o)
      }
      dt = lerpColor(color($), color(0), .4), lt = lerpColor(color(t), color(255), .3), window.x = function(r, g, b) {
        r /= 255, g /= 255, b /= 255, r = r > .04045 ? Math.pow((r + .055) / 1.055, 2.4) : r / 12.92, g = g > .04045 ? Math.pow((g + .055) / 1.055, 2.4) : g / 12.92, b = b > .04045 ? Math.pow((b + .055) / 1.055, 2.4) : b / 12.92;
        return {
          x: r * .4124 + g * .3576 + b * .1805,
          y: r * .2126 + g * .7152 + b * .0722,
          z: r * .0193 + g * .1192 + b * .9505
        }
      }, window.y = function(x, y, z) {
        x /= 0.95047, y /= 1, z /= 1.08883;
        const f = t => t > Math.pow(6 / 29, 3) ? Math.pow(t, 1 / 3) : (1 / 3) * Math.pow(29 / 6, 2) * t + 4 / 29;
        return {
          L: 116 * f(y) - 16,
          a: 500 * (f(x) - f(y)),
          b: 200 * (f(y) - f(z))
        }
      }, window.z = function(c) {
        const {
          x,
          y,
          z
        } = window.x(red(c), green(c), blue(c));
        return window.y(x, y, z)
      }, window.e = function(l1, l2) {
        const {
          L: L1,
          a: a1,
          b: b1
        } = l1, {
          L: L2,
          a: a2,
          b: b2
        } = l2, dL = L2 - L1, LB = (L1 + L2) / 2, C1 = Math.sqrt(a1 * a1 + b1 * b1), C2 = Math.sqrt(a2 * a2 + b2 * b2), CB = (C1 + C2) / 2, a1p = a1 * (1 + .5 * (Math.sqrt(Math.pow(CB, 7) / (Math.pow(CB, 7) + Math.pow(25, 7))))), a2p = a2 * (1 + .5 * (Math.sqrt(Math.pow(CB, 7) / (Math.pow(CB, 7) + Math.pow(25, 7))))), C1p = Math.sqrt(a1p * a1p + b1 * b1), C2p = Math.sqrt(a2p * a2p + b2 * b2), CBp = (C1p + C2p) / 2, dC = C2p - C1p, h1p = Math.atan2(b1, a1p) * 180 / Math.PI, h2p = Math.atan2(b2, a2p) * 180 / Math.PI, dh = Math.abs(h1p - h2p) <= 180 ? h2p - h1p : h2p - h1p > 180 ? h2p - h1p - 360 : h2p - h1p + 360, dH = 2 * Math.sqrt(C1p * C2p) * Math.sin(dh * Math.PI / 360), HB = Math.abs(h1p - h2p) <= 180 ? (h1p + h2p) / 2 : h1p + h2p >= 360 ? (h1p + h2p) / 2 : (h1p + h2p + 360) / 2, T = 1 - .17 * Math.cos(HB * Math.PI / 180 - 30) + .24 * Math.cos(2 * HB * Math.PI / 180) + .32 * Math.cos(3 * HB * Math.PI / 180 + 6) - .2 * Math.cos(4 * HB * Math.PI / 180 - 63), SL = 1 + (.015 * Math.pow(LB - 50, 2)) / Math.sqrt(20 + Math.pow(LB - 50, 2)), SC = 1 + .045 * CBp, SH = 1 + .015 * CBp * T, RT = -Math.sin(2 * (HB * Math.PI / 180 - 55) * Math.PI / 180) * (2 * Math.sqrt(Math.pow(CBp, 7) / (Math.pow(CBp, 7) + Math.pow(25, 7)))), tL = dL / SL, tC = dC / SC, tH = dH / SH;
        return Math.sqrt(tL * tL + tC * tC + tH * tH + RT * tC * tH)
      }, window.p = function(a, b) {
        const lab1 = window.z(a),
          lab2 = window.z(b);
        return window.e(lab1, lab2)
      }, window.g = function($, A, C, U) {
        const s = [],
          r = 2;
        for (let dx = -r; dx <= r; dx++)
          for (let dy = -r; dy <= r; dy++) {
            if (dx === 0 && dy === 0) continue;
            const X = A + dx,
              Y = C + dy;
            if (Y < $.y || Y >= $.y + $.h || X < 0 || X >= w) continue;
            let W = color($.pc);
            noise(X * .1, Y * .1) > .5 && (W = color($.sc));
            s.push(W)
          }
        s.length === 0 && s.push(color($.pc));
        const L = c => {
            const v = t => {
                const h = t / 255;
                return h <= .03928 ? h / 12.92 : Math.pow((h + .055) / 1.055, 2.4)
              },
              RR = v(red(c)),
              G = v(green(c)),
              B = v(blue(c));
            return .2126 * RR + .7152 * G + .0722 * B
          },
          CR = (a, b) => {
            const A = L(a),
              B = L(b),
              l = Math.max(A, B),
              d = Math.min(A, B);
            return (l + .05) / (d + .05)
          },
          P = color($.pc),
          S = color($.sc),
          T = 20,
          D = c => window.p(c, P) > T && window.p(c, S) > T,
          k = [],
          K = new Set,
          M = c => {
            const m = Math.round(red(c)) + '-' + Math.round(green(c)) + '-' + Math.round(blue(c));
            !K.has(m) && (K.add(m), k.push(c))
          },
          q = [];
        p.colors && p.colors.forEach(c => q.push(color(c)));
        const u = new Set,
          O = Math.round(red(P)) + '-' + Math.round(green(P)) + '-' + Math.round(blue(P)),
          Q = Math.round(red(S)) + '-' + Math.round(green(S)) + '-' + Math.round(blue(S));
        u.add(O), u.add(Q);
        const I = [];
        q.forEach(c => {
          const m = Math.round(red(c)) + '-' + Math.round(green(c)) + '-' + Math.round(blue(c));
          !u.has(m) && I.push(c)
        });
        I.forEach(c => {
          const l = (red(c) + green(c) + blue(c)) / (3 * 255),
            d = l > .7 ? .15 : l > .4 ? .2 : .25,
            V = lerpColor(c, color(0, 0, 0), d);
          M(V)
        });
        k.length === 0 && q.forEach(c => {
          const l = (red(c) + green(c) + blue(c)) / (3 * 255),
            d = l > .7 ? .15 : l > .4 ? .2 : .25,
            V = lerpColor(c, color(0, 0, 0), d);
          M(V)
        });
        const E = o => {
          let B = o[0],
            F = -1;
          o.forEach(c => {
            let m = Infinity,
              N = Infinity;
            s.forEach(W => {
              const RR = CR(c, W);
              RR < m && (m = RR);
              const p = window.p(c, W);
              p < N && (N = p)
            });
            const w = .7,
              W = .3,
              Z = Math.min(N / 50, 1),
              J = Math.min(m / 7, 1),
              H = w * Z + W * J;
            H > F && (F = H, B = c)
          });
          return {
            B: B,
            F: F
          }
        };
        let {
          B: B,
          F: F
        } = E(k);
        const G = .6;
        if (F < G && q.length > 0) {
          const H = [];
          q.forEach(c => {
            const l = (red(c) + green(c) + blue(c)) / (3 * 255),
              d = l > .7 ? .15 : l > .4 ? .2 : .25,
              V = lerpColor(c, color(0, 0, 0), d);
            H.push(V);
            const i = l < .3 ? .2 : l < .6 ? .15 : .1,
              J = lerpColor(c, color(255, 255, 255), i);
            H.push(J);
            const R = red(c) / 255,
              G = green(c) / 255,
              B = blue(c) / 255,
              C = (R + G + B) / 3,
              E = C > .5 ? Math.max(0, R - .4) : Math.min(1, R + .4),
              F = C > .5 ? Math.max(0, G - .4) : Math.min(1, G + .4),
              K = C > .5 ? Math.max(0, B - .4) : Math.min(1, B + .4);
            H.push(color(E * 255, F * 255, K * 255))
          });
          B = E(H).B
        }
        return B
      }
    }

    function draw() {
      noStroke();
      fill(222, 222, 222);
      rect(0, 0, width, height);
      push();
      translate(width / 2, height / 2);
      rotate(PI / 2);
      translate(-rH / 2, -rW / 2);
      push();
      translate(2 * f, 2 * f);
      for (const $ of sd) ds($);
      tl > 0 && dtol(Math.floor(tl));
      pop();
      df();
      dl > 0 && ddo(Math.floor(dl));
      dRF(w, h);
      pop()
    }

    function ds($) {
      const t = wp + 1,
        e = wt + 1;
      for (let l = 0; l < w; l += t)
        for (let o = $.y; o < $.y + $.h; o += e) {
          let r = color($.pc),
            _ = !1;
          if (td.length > 0) {
            for (const n of td)
              if (l >= n.x && l < n.x + n.width && o >= n.y && o < n.y + n.height) {
                _ = !0;
                break
              }
          }
          let i = red(r) + window.a(-15, 15),
            a = green(r) + window.a(-15, 15),
            c = blue(r) + window.a(-15, 15);
          if (_) {
            const d = (i + a + c) / 3,
              g = d < 128 ? lt : dt;
            i = red(g), a = green(g), c = blue(g)
          }
          i = constrain(i, 0, 255), a = constrain(a, 0, 255), c = constrain(c, 0, 255), fill(i, a, c), noStroke();
          rect(l + .5 * sin(.05 * o), o, wp, e)
        }
      for (let y = $.y; y < $.y + $.h; y += e)
        for (let b = 0; b < w; b += t) {
          let m = color($.pc),
            S = !1;
          if (td.length > 0) {
            for (const x of td)
              if (b >= x.x && b < x.x + x.width && y >= x.y && y < x.y + x.height) {
                S = !0;
                break
              }
          }
          if ("m" === $.wt && $.sc) noise(.1 * b, .1 * y) > .5 && (m = color($.sc));
          else if ("t" === $.wt) {
            const k = noise(.05 * b, .05 * y);
            m = lerpColor(color($.pc), color(255), .15 * k)
          }
          let A = red(m) + window.a(-20, 20),
            C = green(m) + window.a(-20, 20),
            U = blue(m) + window.a(-20, 20);
          if (S) {
            fill(0, 0, 0, 120);
            noStroke();
            const v = .5 * cos(.05 * b);
            rect(b + .5, y + v + .5, t, wt);
            let q;
            if ("m" === $.wt && $.sc) q = window.g($, b, y, U);
            else {
              const d = (A + C + U) / 3;
              q = d < 128 ? lt : dt
            }
            A = red(q), C = green(q), U = blue(q)
          }
          A = constrain(A, 0, 255), C = constrain(C, 0, 255), U = constrain(U, 0, 255), fill(A, C, U), noStroke();
          const v = .5 * cos(.05 * b);
          rect(b, y + v, t, wt)
        }
      for (let z = $.y; z < $.y + $.h; z += 2 * e)
        for (let B = 0; B < w; B += 2 * t) fill(0, 0, 0, 40), noStroke(), rect(B + 1, z + 1, t - 2, e - 2);
      for (let D = $.y + e; D < $.y + $.h; D += 2 * e)
        for (let E = t; E < w; E += 2 * t) fill(255, 255, 255, 30), noStroke(), rect(E, D, t - 1, e - 1)
    }

    function dto() {
      push(), blendMode(MULTIPLY);
      for (let $ = 0; $ < w; $ += 2)
        for (let t = 0; t < h; t += 2) {
          let e;
          fill(0, 0, 0, map(noise(.02 * $, .02 * t), 0, 1, 0, 50)), noStroke(), rect($, t, 2, 2)
        }
      for (let l = 0; l < w; l += 6)
        for (let o = 0; o < h; o += 6) {
          const r = noise(.03 * l, .03 * o);
          r > .6 ? (fill(255, 255, 255, 25), noStroke(), rect(l, o, 6, 6)) : r < .4 && (fill(0, 0, 0, 20), noStroke(), rect(l, o, 6, 6))
        }
      pop()
    }

    function dtol($) {
      const t = 10 + 19 * $,
        e = 5 + 10 * $,
        l = .7 - .05 * $;
      push(), blendMode(MULTIPLY);
      for (let o = 0; o < w; o += 2)
        for (let r = 0; r < h; r += 2) {
          let _;
          fill(0, 0, 0, map(noise(.02 * o, .02 * r), 0, 1, 0, t)), noStroke(), rect(o, r, 2, 2)
        }
      for (let n = 0; n < w; n += 6)
        for (let i = 0; i < h; i += 6) {
          const a = noise(.03 * n, .03 * i);
          a > l ? (fill(255, 255, 255, e), noStroke(), rect(n, i, 6, 6)) : a < 1 - l && (fill(0, 0, 0, .8 * e), noStroke(), rect(n, i, 6, 6))
        }
      if ($ >= 4)
        for (let c = 0; c < w; c += 8)
          for (let d = 0; d < h; d += 8) noise(.01 * c, .01 * d) > .7 && (fill(0, 0, 0, 15), noStroke(), rect(c, d, 8, 2));
      if ($ >= 7)
        for (let g = 0; g < w; g += 4)
          for (let y = 0; y < h; y += 4) noise(.005 * g, .005 * y) > .8 && (fill(0, 0, 0, 25), noStroke(), rect(g, y, 4, 1));
      if ($ >= 9)
        for (let y = 0; y < w; y += 12)
          for (let b = 0; b < h; b += 12) noise(.002 * y, .002 * b) > .75 && (fill(0, 0, 0, 35), noStroke(), rect(y, b, 12, 1));
      pop()
    }

    function ddo($) {
      const t = 1 === $ ? .5 : 1,
        e = 1 === $ ? 30 : 60;
      push(), translate(2 * f, 2 * f);
      for (let l = 0; l < w; l += 3)
        for (let o = 0; o < h; o += 3) {
          const r = window.a(0, 1),
            _ = .85 * t;
          if (r > _) {
            const n = window.a(1, 4),
              i = window.a(.5 * e, e),
              a = window.a(60, 90),
              c = window.a(40, 60),
              d = window.a(20, 40);
            fill(a, c, d, i), noStroke(), ellipse(l, o, n, n)
          }
        }
      for (let g = 0; g < 15 * t; g++) {
        const y = window.a(0, w),
          b = window.a(0, h),
          m = window.a(8, 20),
          S = window.a(.3 * e, .7 * e),
          x = window.a(40, 70),
          k = window.a(25, 45),
          A = window.a(15, 30);
        fill(x, k, A, S), noStroke(), ellipse(y, b, m, m)
      }
      for (let C = 0; C < w; C += 2)
        for (let U = 0; U < h; U += 2) {
          const j = Math.min(C, U, w - C, h - U);
          if (j < 10) {
            const q = window.a(0, 1);
            if (q > .7 * t) {
              const v = window.a(10, 25);
              fill(80, 50, 20, v), noStroke(), rect(C, U, 2, 2)
            }
          }
        }
      pop()
    }

    function df() {
      dfs(2 * f, f, w, f, "top"), dfs(2 * f, 2 * f + h + 1, w, f, "bottom"), dse()
    }

    function dfs($, t, e, l, o) {
      const r = e / 12,
        _ = e / r;
      for (let n = 0; n < r; n++) {
        const i = $ + n * _;
        if (!p || !p.colors) return;
        const a = window.c(p.colors);
        for (let c = 0; c < 12; c++) {
          const d = i + window.a(-_ / 6, _ / 6),
            g = "top" === o ? t + l : t,
            y = "top" === o ? t : t + l,
            b = window.a(1, 4),
            m = window.a(.2, .8),
            S = window.c([-1, 1]),
            x = window.a(.5, 2),
            k = window.a(.8, 1.2),
            A = color(a),
            C = .7 * red(A),
            U = .7 * green(A),
            j = .7 * blue(A);
          stroke(C, U, j), strokeWeight(window.a(.5, 1.2)), noFill(), beginShape();
          for (let q = 0; q <= 1; q += .1) {
            let v = lerp(g, y, q * k),
              z = sin(q * PI * m) * b * q * S * x;
            z += window.a(-1, 1), .3 > window.b() && (z += window.a(-2, 2)), vertex(d + z, v)
          }
          endShape()
        }
      }
    }

    function dse() {
      const $ = wt + 1;

      function t(t) {
        const e = "left" === t ? 0 : w,
          l = "left" === t ? 0 : PI;
        for (const o of sd)
          for (let r = o.y; r < o.y + o.h; r += $) {
            if (r === o.y || o === sd[sd.length - 1] && r + $ >= o.y + o.h) continue;
            let _ = color(o.pc);
            if (o.sc && "m" === o.wt) {
              const n = color(o.sc);
              _ = lerpColor(_, n, .5 * noise(.1 * r) + .5)
            }
            const i = .8 * red(_),
              a = .8 * green(_),
              c = .8 * blue(_);
            fill(i, a, c), noStroke();
            let d = wt * window.a(1.2, 1.8),
              g = 2 * f + e + window.a(-2, 2),
              y = 2 * f + r + wt / 2 + window.a(-1, 1),
              b;
            dtsa(g, y, d, l + HALF_PI + window.a(-.2, .2), l - HALF_PI + window.a(-.2, .2), i, a, c, t)
          }
      }
      t("left"), t("right")
    }

    function dtsa($, t, e, l, o, r, _, n, i) {
      const a = max(6, floor(e / 1.2)),
        c = e / a;
      for (let d = 0; d < a; d++) {
        let g = e - d * c,
          y, b, m;
        d % 2 == 0 ? (y = constrain(r + 25, 0, 255), b = constrain(_ + 25, 0, 255), m = constrain(n + 25, 0, 255)) : (y = constrain(r - 20, 0, 255), b = constrain(_ - 20, 0, 255), m = constrain(n - 20, 0, 255)), fill(y, b, m, 88), arc($, t, 2 * g, 2 * g, l, o)
      }
      fill(.6 * r, .6 * _, .6 * n, 70), arc($ + ("left" === i ? 1 : -1), t + 1, 2 * e, 2 * e, l, o);
      for (let S = 0; S < 5; S++) {
        const x = window.a(l, o),
          k = e * window.a(.2, .7),
          A = $ + cos(x) * k,
          C = t + sin(x) * k;
        fill(r, _, n, 120), ellipse(A, C, window.a(1.5, 3.5), window.a(1.5, 3.5))
      }
    }

    function gtd() {
      td = [];
      const $ = tr || [];
      if (!$ || 0 === $.length) return;
      const t = $.filter($ => $ && "" !== $.trim());
      if (0 === t.length) return;
      let e = wp + 1,
        l = wt + 1,
        o = e * ts,
        r = l * ts,
        _ = 7 * o,
        n = 5 * r,
        i = r,
        a = 1.5 * _,
        c = t.length * _ + (t.length - 1) * a,
        d = (w - c) / 2,
        g = 0;
      for (let y = 0; y < $.length; y++) {
        const b = $[y];
        if (!b || "" === b.trim()) continue;
        const m = _,
          S = b.length * (n + i) - i,
          x = d + g * (_ + a),
          k = (h - S) / 2;
        for (let A = 0; A < b.length; A++) {
          const C = b.charAt(A),
            U = k + (b.length - 1 - A) * (n + i),
            j = gcp(C, x, U, m, n);
          td.push(...j)
        }
        g++
      }
    }

    function gcp($, t, e, l, o) {
      const r = [],
        _ = wp + 1,
        n = wt + 1,
        i = _ * ts,
        a = n * ts,
        c = cm[$.toUpperCase()] || cm[" "],
        d = c.length,
        g = c[0].length;
      for (let y = 0; y < d; y++)
        for (let b = 0; b < g; b++)
          if ("1" === c[y][b]) {
            const m = y,
              S = g - 1 - b;
            r.push({
              x: t + m * i,
              y: e + S * a,
              width: i,
              height: a
            })
          } return r
    }

  </script>
</body>

</html>
