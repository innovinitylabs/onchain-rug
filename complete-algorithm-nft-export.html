<!DOCTYPE html><html><head><meta charset="UTF-8"><title>NFT#6809</title><style>body{margin:0;padding:0;background:#000;display:flex;justify-content:center;align-items:center;min-height:100vh;font-family:Arial,sans-serif}canvas{border-radius:8px;box-shadow:0 4px 8px rgba(255,255,255,0.1)}.i{position:absolute;top:10px;left:10px;color:#fff;font-size:10px;opacity:0.7}.t{position:absolute;top:10px;right:10px;color:#fff;font-size:8px;opacity:0.7;text-align:right}</style><script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/p5.min.js"></script></head><body><div class="i">S:6809|P:Chennai Monsoon</div><div class="t">textLines:1|totalCharacters:5|paletteName:Chennai Monsoon|paletteRarity:Uncommon|stripeCount:2|stripeComplexity:Complex</div><div id="c"></div><div style="position:absolute;left:0;top:calc(100% + 20px);width:100%;height:auto;opacity:0;pointer-events:none;user-select:none;font-size:1px;color:transparent;z-index:-1;">Bengal Famine 1770 Bengal Famine 1873 Bengal Famine 1943 Irish Famine Orissa Famine 1866 Madras Famine 1876 Jallianwala Bagh Amritsar Massacre Salt Tax Partition of India Indian Rebellion 1857 Mau Mau Uprising Boer Camps Malayan Emergency Opium Wars Drain of Wealth Deindustrialisation Indigo Revolt Forced Opium Farming Enfield Cartridges Tasmanian Genocide Aboriginal Massacres Caribbean Slavery Atlantic Slave Trade Plantation Famines Benin Bronzes Looting Koh-i-Noor Plunder Scramble for Africa Native American Genocide Congo Free State Armenian Genocide Khmer Rouge Unit 731 Apartheid Iraq War Toll Guantanamo Torture Climate Colonialism Corporate Colonialism Resource Plunder Indigenous Land Theft Highland Clearances Criminal Tribes Act Suppression of Irish Gaelic Banning Indian Languages Cultural Erasure Māori Colonial Amnesia Decolonize Looted Erased Suppressed Censored Plunder Divide and Rule Cultural Theft Stolen Voices Swept Under the Rug Colonialism Famine Partition Exploitation Resistance Independence Slavery Oppression Resilience Diaspora Identity Justice Healing Memory Heritage Tradition Land Language Culture Freedom Unity Struggle Rebellion Revolution Community Self-Determination Ancestry Displacement Survival Trauma Reparations Solidarity Decolonization British Engineered Famines Indian Diabetes Gaza Israel Palestine Genocide Occupation Imperialism Global South Solidarity Decolonial Resistance Imperial Echoes Structural Violence Tanzanian Maji-Maji Rebellion Britishgenocides Colonial barbarisms ReinventionOfSlaveryWithIndenture</div><script>const config = { DOORMAT_WIDTH: 800, DOORMAT_HEIGHT: 1200, FRINGE_LENGTH: 30, WEFT_THICKNESS: 8, TEXT_SCALE: 2, MAX_CHARS: 11, MAX_TEXT_ROWS: 5 }; let அ = config.DOORMAT_WIDTH; let ஆ = config.DOORMAT_HEIGHT; let இ = config.FRINGE_LENGTH; let ஈ = config.WEFT_THICKNESS; let உ = 2; let TEXT_SCALE = config.TEXT_SCALE; let MAX_CHARS = config.MAX_CHARS; let ஊ = {"name":"Chennai Monsoon","colors":["#1d3557","#457b9d","#a8dadc","#f1faee","#ffd700","#e94f37","#393e41","#3f88c5"]}; let எ = [{"y":0,"height":63.82,"primaryColor":"#393e41","secondaryColor":null,"textureType":"textured","complexity":0.24},{"y":63.82,"height":60.37,"primaryColor":"#ffd700","secondaryColor":"#393e41","textureType":"textured","complexity":0.16}]; let ஏ = ["ASRGE"]; let ஐ = []; let lightTextColor, darkTextColor; const characterMap = {"A":{"pixels":[]},"S":{"pixels":[]},"R":{"pixels":[]},"G":{"pixels":[]},"E":{"pixels":[]}," ":{"pixels":[]}}; function setup() { let totalWidth = அ + இ * 4; let totalHeight = ஆ + இ * 4; createCanvas(totalHeight, totalWidth); pixelDensity(1); noLoop(); randomSeed(6809); noiseSeed(6809); updateTextColors(); generateTextData(); draw(); } function draw() { background(222, 222, 222); push(); translate(width/2, height/2); rotate(PI/2); translate(-height/2, -width/2); push(); translate(இ * 2, இ * 2); for (let stripe of எ) { drawStripe(stripe); } drawTextureOverlay(); pop(); drawFringe(); drawSelvedgeEdges(); pop(); } function updateTextColors() { if (!ஊ || !ஊ.colors) return; let darkest = ஊ.colors[0]; let lightest = ஊ.colors[0]; let darkestVal = 999, lightestVal = -1; for (let hex of ஊ.colors) { let c = color(hex); let bright = (red(c) + green(c) + blue(c)) / 3; if (bright < darkestVal) { darkestVal = bright; darkest = hex; } if (bright > lightestVal) { lightestVal = bright; lightest = hex; } } darkTextColor = color(darkest); lightTextColor = lerpColor(color(lightest), color(255), 0.3); darkTextColor = lerpColor(color(darkest), color(0), 0.4); } function drawStripe(stripe) { let warpSpacing = உ + 1; let weftSpacing = ஈ + 1; for (let x = 0; x < அ; x += warpSpacing) { for (let y = stripe.y; y < stripe.y + stripe.height; y += weftSpacing) { let baseColor = color(stripe.primaryColor); let isTextPixel = false; if (ஐ.length > 0) { for (let textPixel of ஐ) { if (x >= textPixel.x && x < textPixel.x + textPixel.width && y >= textPixel.y && y < textPixel.y + textPixel.height) { isTextPixel = true; break; } } } let r = red(baseColor) + random(-15, 15); let g = green(baseColor) + random(-15, 15); let b = blue(baseColor) + random(-15, 15); if (isTextPixel) { const brightness = (r + g + b) / 3; let textColor = brightness < 128 ? lightTextColor : darkTextColor; r = red(textColor); g = green(textColor); b = blue(textColor); } r = constrain(r, 0, 255); g = constrain(g, 0, 255); b = constrain(b, 0, 255); fill(r, g, b); noStroke(); let warpOffset = sin(y * 0.05) * 0.5; rect(x + warpOffset, y, உ, weftSpacing); } } for (let y = stripe.y; y < stripe.y + stripe.height; y += weftSpacing) { for (let x = 0; x < அ; x += warpSpacing) { let baseColor = color(stripe.primaryColor); let isTextPixel = false; if (ஐ.length > 0) { for (let textPixel of ஐ) { if (x >= textPixel.x && x < textPixel.x + textPixel.width && y >= textPixel.y && y < textPixel.y + textPixel.height) { isTextPixel = true; break; } } } if (stripe.textureType === 'mixed' && stripe.secondaryColor) { if (noise(x * 0.1, y * 0.1) > 0.5) { baseColor = color(stripe.secondaryColor); } } else if (stripe.textureType === 'textured') { let noiseValue = noise(x * 0.05, y * 0.05); baseColor = lerpColor(color(stripe.primaryColor), color(255), noiseValue * 0.15); } let r = red(baseColor) + random(-20, 20); let g = green(baseColor) + random(-20, 20); let b = blue(baseColor) + random(-20, 20); if (isTextPixel) { const brightness = (r + g + b) / 3; let textColor = brightness < 128 ? lightTextColor : darkTextColor; r = red(textColor); g = green(textColor); b = blue(textColor); } r = constrain(r, 0, 255); g = constrain(g, 0, 255); b = constrain(b, 0, 255); fill(r, g, b); noStroke(); let weftOffset = cos(x * 0.05) * 0.5; rect(x, y + weftOffset, warpSpacing, ஈ); } } for (let y = stripe.y; y < stripe.y + stripe.height; y += weftSpacing * 2) { for (let x = 0; x < அ; x += warpSpacing * 2) { fill(0, 0, 0, 40); noStroke(); rect(x + 1, y + 1, warpSpacing - 2, weftSpacing - 2); } } for (let y = stripe.y + weftSpacing; y < stripe.y + stripe.height; y += weftSpacing * 2) { for (let x = warpSpacing; x < அ; x += warpSpacing * 2) { fill(255, 255, 255, 30); noStroke(); rect(x, y, warpSpacing - 1, weftSpacing - 1); } } } function drawTextureOverlay() { push(); blendMode(MULTIPLY); for (let x = 0; x < அ; x += 2) { for (let y = 0; y < ஆ; y += 2) { let noiseValue = noise(x * 0.02, y * 0.02); let alpha = map(noiseValue, 0, 1, 0, 50); fill(0, 0, 0, alpha); noStroke(); rect(x, y, 2, 2); } } for (let x = 0; x < அ; x += 6) { for (let y = 0; y < ஆ; y += 6) { let noiseValue = noise(x * 0.03, y * 0.03); if (noiseValue > 0.6) { fill(255, 255, 255, 25); noStroke(); rect(x, y, 6, 6); } else if (noiseValue < 0.4) { fill(0, 0, 0, 20); noStroke(); rect(x, y, 6, 6); } } } pop(); } function drawFringe() { drawFringeSection(இ * 2, இ, அ, இ, 'top'); drawFringeSection(இ * 2, இ * 2 + ஆ, அ, இ, 'bottom'); drawBorder(); } function drawSelvedgeEdges() { let weftSpacing = ஈ + 1; let isFirst = true; let isLast = false; for (let stripe of எ) { for (let y = stripe.y; y < stripe.y + stripe.height; y += weftSpacing) { if (isFirst) { isFirst = false; continue; } if (stripe === எ[எ.length - 1] && y + weftSpacing >= stripe.y + stripe.height) { isLast = true; continue; } let baseColor = color(stripe.primaryColor); if (stripe.secondaryColor && stripe.textureType === 'mixed') { let secondaryColor = color(stripe.secondaryColor); let blendFactor = noise(y * 0.1) * 0.5 + 0.5; baseColor = lerpColor(baseColor, secondaryColor, blendFactor); } let r = red(baseColor) * 0.8; let g = green(baseColor) * 0.8; let b = blue(baseColor) * 0.8; fill(r, g, b); noStroke(); let radius = ஈ * random(1.2, 1.8); let centerX = இ * 2 + random(-2, 2); let centerY = இ * 2 + y + ஈ/2 + random(-1, 1); let startAngle = HALF_PI + random(-0.2, 0.2); let endAngle = -HALF_PI + random(-0.2, 0.2); drawTexturedSelvedgeArc(centerX, centerY, radius, startAngle, endAngle, r, g, b, 'left'); } } isFirst = true; isLast = false; for (let stripe of எ) { for (let y = stripe.y; y < stripe.y + stripe.height; y += weftSpacing) { if (isFirst) { isFirst = false; continue; } if (stripe === எ[எ.length - 1] && y + weftSpacing >= stripe.y + stripe.height) { isLast = true; continue; } let baseColor = color(stripe.primaryColor); if (stripe.secondaryColor && stripe.textureType === 'mixed') { let secondaryColor = color(stripe.secondaryColor); let blendFactor = noise(y * 0.1) * 0.5 + 0.5; baseColor = lerpColor(baseColor, secondaryColor, blendFactor); } let r = red(baseColor) * 0.8; let g = green(baseColor) * 0.8; let b = blue(baseColor) * 0.8; fill(r, g, b); noStroke(); let radius = ஈ * random(1.2, 1.8); let centerX = இ * 2 + அ + random(-2, 2); let centerY = இ * 2 + y + ஈ/2 + random(-1, 1); let startAngle = -HALF_PI + random(-0.2, 0.2); let endAngle = HALF_PI + random(-0.2, 0.2); drawTexturedSelvedgeArc(centerX, centerY, radius, startAngle, endAngle, r, g, b, 'right'); } } } function drawFringeSection(x, y, w, h, side) { let segments = w / 12; let segmentWidth = w / segments; for (let i = 0; i < segments; i++) { let segmentX = x + i * segmentWidth; let baseColor = random(ஊ.colors); for (let j = 0; j < 12; j++) { let threadX = segmentX + random(-segmentWidth/6, segmentWidth/6); let startY = side === 'top' ? y + h : y; let endY = side === 'top' ? y : y + h; let amplitude = random(1, 4); let frequency = random(0.2, 0.8); let direction = random([-1, 1]); let phase = random(0.5, 2.0); let stretch = random(0.8, 1.2); let threadColor = color(baseColor); let r = red(threadColor) * 0.7; let g = green(threadColor) * 0.7; let b = blue(threadColor) * 0.7; stroke(r, g, b); strokeWeight(random(0.5, 1.2)); noFill(); beginShape(); for (let t = 0; t <= 1; t += 0.1) { let threadY = lerp(startY, endY, t * stretch); let threadX = sin(t * PI * frequency) * amplitude * t * direction * phase; threadX += random(-1, 1); if (random() < 0.3) { threadX += random(-2, 2); } vertex(threadX, threadY); } endShape(); } } } function drawTexturedSelvedgeArc(centerX, centerY, radius, startAngle, endAngle, r, g, b, side) { let detail = max(6, floor(radius / 1.2)); let step = radius / detail; for (let i = 0; i < detail; i++) { let currentRadius = radius - (i * step); let arcR, arcG, arcB; if (i % 2 === 0) { arcR = constrain(r + 25, 0, 255); arcG = constrain(g + 25, 0, 255); arcB = constrain(b + 25, 0, 255); } else { arcR = constrain(r - 20, 0, 255); arcG = constrain(g - 20, 0, 255); arcB = constrain(b - 20, 0, 255); } arcR = constrain(arcR + random(-10, 10), 0, 255); arcG = constrain(arcG + random(-10, 10), 0, 255); arcB = constrain(arcB + random(-10, 10), 0, 255); fill(arcR, arcG, arcB, 88); let offsetX = centerX + random(-1, 1); let offsetY = centerY + random(-1, 1); let angleStart = startAngle + random(-0.1, 0.1); let angleEnd = endAngle + random(-0.1, 0.1); arc(offsetX, offsetY, currentRadius * 2, currentRadius * 2, angleStart, angleEnd); } for (let i = 0; i < 3; i++) { let detailRadius = radius * (0.3 + i * 0.2); let detailAlpha = 180 - (i * 40); let detailR = constrain(r + (i % 2 === 0 ? 15 : -15), 0, 255); let detailG = constrain(g + (i % 2 === 0 ? 15 : -15), 0, 255); let detailB = constrain(b + (i % 2 === 0 ? 15 : -15), 0, 255); fill(detailR, detailG, detailB, detailAlpha * 0.7); let detailX = centerX + random(-0.5, 0.5); let detailY = centerY + random(-0.5, 0.5); let detailStartAngle = startAngle + random(-0.05, 0.05); let detailEndAngle = endAngle + random(-0.05, 0.05); arc(detailX, detailY, detailRadius * 2, detailRadius * 2, detailStartAngle, detailEndAngle); } fill(r * 0.6, g * 0.6, b * 0.6, 70); let shadowOffset = side === 'left' ? 1 : -1; arc(centerX + shadowOffset, centerY + 1, radius * 2, radius * 2, startAngle, endAngle); noFill(); arc(centerX, centerY, radius * 0.5, radius * 0.5, startAngle, endAngle); for (let i = 0; i < 8; i++) { let angle = random(startAngle, endAngle); let distance = radius * random(0.2, 0.7); let dotX = centerX + cos(angle) * distance; let dotY = centerY + sin(angle) * distance; if (i % 2 === 0) { fill(r + 20, g + 20, b + 20, 120); } else { fill(r - 15, g - 15, b - 15, 120); } noStroke(); ellipse(dotX, dotY, random(1.5, 3.5), random(1.5, 3.5)); } } function drawBorder() { stroke(100); strokeWeight(2); noFill(); rect(-இ * 2, -இ * 2, அ + இ * 4, ஆ + இ * 4); } function generateTextData() { ஐ = []; const textRows = ஏ || []; if (!textRows || textRows.length === 0) return; const warpSpacing = உ + 1; const weftSpacing = ஈ + 1; const charWidth = warpSpacing * TEXT_SCALE; const charHeight = weftSpacing * TEXT_SCALE; const charSpacing = charWidth * 1.5; const rowSpacing = charHeight * 1.5; const totalWidth = textRows.length * charWidth + (textRows.length - 1) * charSpacing; const startX = (அ - totalWidth) / 2; for (let rowIndex = 0; rowIndex < textRows.length; rowIndex++) { const rowText = textRows[rowIndex]; if (!rowText) continue; const rowWidth = charWidth; const rowHeight = rowText.length * (charHeight + charSpacing) - charSpacing; const startY = (ஆ - rowHeight) / 2; for (let i = 0; i < rowText.length; i++) { const char = rowText.charAt(i); const charY = startY + (rowText.length - 1 - i) * (charHeight + charSpacing); const charPixels = generateCharacterPixels(char, startX, charY, rowWidth, charHeight); ஐ.push(...charPixels); } } } function generateCharacterPixels(char, x, y, width, height) { const pixels = []; const warpSpacing = உ + 1; const weftSpacing = ஈ + 1; const charWarp = warpSpacing * TEXT_SCALE; const charWeft = weftSpacing * TEXT_SCALE; const charMap = { 'A': [[0,1,1,1,0], [1,0,0,0,1], [1,0,0,0,1], [1,1,1,1,1], [1,0,0,0,1], [1,0,0,0,1], [1,0,0,0,1]], 'S': [[0,1,1,1,1], [1,0,0,0,0], [1,0,0,0,0], [0,1,1,1,0], [0,0,0,0,1], [0,0,0,0,1], [1,1,1,1,0]], 'R': [[1,1,1,1,0], [1,0,0,0,1], [1,0,0,0,1], [1,1,1,1,0], [1,0,1,0,0], [1,0,0,1,0], [1,0,0,0,1]], 'G': [[0,1,1,1,1], [1,0,0,0,0], [1,0,0,0,0], [1,0,0,1,1], [1,0,0,0,1], [1,0,0,0,1], [0,1,1,1,1]], 'E': [[1,1,1,1,1], [1,0,0,0,0], [1,0,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,0,0,0,0], [1,1,1,1,1]], ' ': [[0,0,0,0,0], [0,0,0,0,0], [0,0,0,0,0], [0,0,0,0,0], [0,0,0,0,0], [0,0,0,0,0], [0,0,0,0,0]] }; const charData = charMap[char.toUpperCase()] || charMap[' ']; const rows = charData.length; const cols = charData[0].length; for (let row = 0; row < rows; row++) { for (let col = 0; col < cols; col++) { if (charData[row][col] === 1) { const pixelRow = row; const pixelCol = cols - 1 - col; pixels.push({ x: x + pixelRow * charWarp, y: y + pixelCol * charWeft, width: charWarp, height: charWeft }); } } } return pixels; }</script></body></html>